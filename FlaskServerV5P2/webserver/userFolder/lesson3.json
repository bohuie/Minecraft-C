[
    {
        "instructions": "<h1>Shortest Path</h1><br/> <h3>Hi welcome to the Chicken Farm lesson.<br/>It is too hard to deliver all the parcels in person. A courier asks you to help him develop a program that makes a robot to deliver automatically. But remember, the fuel of a robot is limited. <br/>You have to be careful when you design a route for the robot. Try to make it as short as possible!</h3> <br/></br>(this is a tutorial page please click NEXT to the next page)<br/><img src='../static/img/lesson3/lesson3title.png' class='relative'/>",
        "starterCode": "# Click next to continue",
        "code": "# Click next to continue",
        "answer": "Hello World!",
        "plotname": "",
        "haveplot": false,
        "nextLocked": false
    },
    {
        "instructions": "<h1>Step 1:</h1><br/> <h3>Now here shows the map, there are multiple choice from one house to another. To simplify the question,we can consider each house as a node and each path between them as an edge. And now we need to convert the mapinto something that computer can read. Create a list to store every edge in it, including start node and end node. And also a list contains all nodes.</h3> <br/><img src='../static/img/lesson3/sample1.png' class='relative'/><br/>",
        "starterCode": "'''\r\nHint: To start your convertion, you may use the following pseudo code:\r\n  Map = [(House name1,House name2, value),...]  \r\n  //[House name1] is the current location. The [House name2] is another house which directly \r\nconnected with the current. [value] is the distance between these two house. \r\nRemember you need to make sure every house is included.)\r\n'''\r\nMap = [\r\n    ('A','B',1),('A','C',2),\r\n    ('B','C',6),('B','D',11),\r\n    ('C','D',9),('C','E',13),\r\n    ('D','E',7),('D','F',3),\r\n    ('E','F',4)\r\n    ]\r\nnodes = ('ABCDEF')",
        "code": "'''\r\nHint: To start your convertion, you may use the following pseudo code:\r\n  Map = [(House name1,House name2, value),...]  \r\n  //[House name1] is the current location. The [House name2] is another house which directly \r\nconnected with the current. [value] is the distance between these two house. \r\nRemember you need to make sure every house is included.)\r\n'''\r\nMap = [\r\n    ('A','B',1),('A','C',2),\r\n    ('B','C',6),('B','D',11),\r\n    ('C','D',9),('C','E',13),\r\n    ('D','E',7),('D','F',3),\r\n    ('E','F',4)\r\n    ]\r\nnodes = ('ABCDEF')",
        "answer": "Hello World!",
        "plotname": "",
        "haveplot": false,
        "nextLocked": false
    },
    {
        "instructions": "<h1>Step 2:</h1><br/> <h3>Well done! Now it's time to prepair for next code. Finish the following readding before we continue. </h3><br/> <img src='../static/img/lesson3/treesample.png' class='relative'/>",
        "starterCode":"'''\r\n1. What is Minimum Spanning Tree?\r\n    'Given a connected and undirected graph, a spanning tree of that graph is a subgraph that is a tree and connects all the vertices together.'\r\n    The number of spanning tree on a graph is not limited. However, to solve the problem in this lesson, we need to find the minimum spanning tree.\r\n    A minimum spanning tree has the smallest weight compared with all other spanning trees for a graph. \r\n    'The weight of a spanning tree is the sum of weights given to each edge of the spanning tree.'\r\n    In this lesson, the weight of an edge represents the distance between two house. \r\n    There will be only (number of nodes -1) edges in a minimum spanning tree.\r\n2. How does a Kruskal's algorithm work?\r\n\r\n    i. The algorithm sorts all the edges in increasing order of their weight.\r\n\r\n    ii. Start with the smallest edge. If it can not form a cycle with the tree we have so far, then add this edge to the tree.\r\n    Otherwise we discard it.\r\n\r\n    iii. Repeat step2 until there are [(number of nodes) - 1] edges in the tree.\r\n\r\n It's ok if you do not totally understand. We will explain more in the next step.'''",
        "code": "'''\r\n1. What is Minimum Spanning Tree?\r\n    'Given a connected and undirected graph, a spanning tree of that graph is a subgraph that is a tree and connects all the vertices together.'\r\n    The number of spanning tree on a graph is not limited. However, to solve the problem in this lesson, we need to find the minimum spanning tree.\r\n    A minimum spanning tree has the smallest weight compared with all other spanning trees for a graph. \r\n    'The weight of a spanning tree is the sum of weights given to each edge of the spanning tree.'\r\n    In this lesson, the weight of an edge represents the distance between two house. \r\n    There will be only (number of nodes -1) edges in a minimum spanning tree.\r\n2. How does a Kruskal's algorithm work?\r\n\r\n    i. The algorithm sorts all the edges in increasing order of their weight.\r\n\r\n    ii. Start with the smallest edge. If it can not form a cycle with the tree we have so far, then add this edge to the tree.\r\n    Otherwise we discard it.\r\n\r\n    iii. Repeat step2 until there are [(number of nodes) - 1] edges in the tree.\r\n\r\n It's ok if you do not totally understand. We will explain more in the next step.'''",
        "answer": "Hello World!",
        "plotname": "",
        "haveplot": false,
        "nextLocked": false
    },
    {
        "instructions": "<h1>Step 3:</h1><br/> <h3>In this part, you will create your own algorithm based on Step 2.2. <br/>First, we need to sort edges in increasing order by using sort(key=lambda x:x[2]) Map.sort(key=lambda x:x[2])<br/>Second, initialize a new tree. We will use a new data structure 'Dictionary'. Data in dictionary will be like {[key]:[value]}, where key is the name of data and value is the data stored. We want the current node be the key and the nodes connected with the current is the value. You can run this code with print() to see what happen. <br/>Try to use the following pseudo code:</h3> <br/>",
        "starterCode":"Map = [\r\n    ('A','B',1),('A','C',2),\r\n    ('B','C',6),('B','D',11),\r\n    ('C','D',9),('C','E',13),\r\n    ('D','E',7),('D','F',3),\r\n    ('E','F',4)\r\n    ]\r\nnodes = ('ABCDEF')\r\nMap.sort(key=lambda x:x[2])\r\n'''\r\ntree=dict()\r\nfor loop for all elements in nodes:\r\n    let each node connect with itself (we will deal with this later.)\r\n'''\r\ntrees=dict()\r\nfor i in nodes:\r\n    trees[i]=i\r\nprint(Map)\r\nprint(trees)",
        "code": "Map = [\r\n    ('A','B',1),('A','C',2),\r\n    ('B','C',6),('B','D',11),\r\n    ('C','D',9),('C','E',13),\r\n    ('D','E',7),('D','F',3),\r\n    ('E','F',4)\r\n    ]\r\nnodes = ('ABCDEF')\r\nMap.sort(key=lambda x:x[2])\r\n'''\r\ntree=dict()\r\nfor loop for all elements in nodes:\r\n    let each node connect with itself (we will deal with this later.)\r\n'''\r\ntrees=dict()\r\nfor i in nodes:\r\n    trees[i]=i\r\nprint(Map)\r\nprint(trees)",
        "answer": "Hello World!",
        "plotname": "",
        "haveplot": false,
        "nextLocked": false
    },
    {
        "instructions": "<h1>Step 4:</h1><br/> <h3>Now let's start with build a function named find(). <br/>It is used to find the root nodes. So that this tree will record connected nodes. <br/>For better comprehension, see the example. if we connect node A with B and B with C, using find_node() to A, it will tell us node C is the end of the connection and let C be the root node of A.</h3>",
        "starterCode": "Map = [\r\n    ('A','B',1),('A','C',2),\r\n    ('B','C',6),('B','D',11),\r\n    ('C','D',9),('C','E',13),\r\n    ('D','E',7),('D','F',3),\r\n    ('E','F',4)\r\n    ]\r\nnodes = ('ABCDEF')\r\nMap.sort(key=lambda x:x[2])\r\n'''\r\ntree=dict()\r\nfor loop for all elements in nodes:\r\n    let each node connect with itself (we will deal with this later.)\r\n'''\r\ntrees=dict()\r\nfor i in nodes:\r\n    trees[i]=i\r\nprint(Map)\r\nprint(trees)\r\ndef find_node(x):\r\n    if trees[x]!=x:\r\n        trees[x]=find_node(trees[x])\r\n    return trees[x]\r\n#Example here\r\ntrees['A']='B'\r\ntrees['B']='C'\r\nprint(trees)\r\nprint(find_node('A'))\r\nprint(trees)",
        "code": "Map = [\r\n    ('A','B',1),('A','C',2),\r\n    ('B','C',6),('B','D',11),\r\n    ('C','D',9),('C','E',13),\r\n    ('D','E',7),('D','F',3),\r\n    ('E','F',4)\r\n    ]\r\nnodes = ('ABCDEF')\r\nMap.sort(key=lambda x:x[2])\r\n'''\r\ntree=dict()\r\nfor loop for all elements in nodes:\r\n    let each node connect with itself (we will deal with this later.)\r\n'''\r\ntrees=dict()\r\nfor i in nodes:\r\n    trees[i]=i\r\nprint(Map)\r\nprint(trees)\r\ndef find_node(x):\r\n    if trees[x]!=x:\r\n        trees[x]=find_node(trees[x])\r\n    return trees[x]\r\n#Example here\r\ntrees['A']='B'\r\ntrees['B']='C'\r\nprint(trees)\r\nprint(find_node('A'))\r\nprint(trees)",
        "answer": "Hello World!",
        "plotname": "",
        "haveplot": false,
        "nextLocked": false
    },
    {
        "instructions": "<h1>Step 5:</h1><br/> <h3>Let's initialize our minimum spanning tree in this step by using :<br/>'mst=[]  n=len(nodes)-1'. It created a blank dictionary. This step is just a preparation  for next step</h3>",
        "starterCode": "mst=[]\r\nn=len(nodes)-1",
        "code": "Map = [\r\n    ('A','B',1),('A','C',2),\r\n    ('B','C',6),('B','D',11),\r\n    ('C','D',9),('C','E',13),\r\n    ('D','E',7),('D','F',3),\r\n    ('E','F',4)\r\n    ]\r\nnodes = ('ABCDEF')\r\nMap.sort(key=lambda x:x[2])\r\n'''\r\ntree=dict()\r\nfor loop for all elements in nodes:\r\n    let each node connect with itself (we will deal with this later.)\r\n'''\r\ntrees=dict()\r\nfor i in nodes:\r\n    trees[i]=i\r\nmst=[]\r\nn=len(nodes)-1",
        "answer": "Hello World!",
        "plotname": "",
        "haveplot": false,
        "nextLocked": false
    },
    {
        "instructions": "<h1>Step 6:</h1><br/> <h3>The last step to create our algorithm is to write a loop which traverse all edge in Map.<br/>Remember in Step 2.2.ii, before we add edges in mst[], use find() to check if this edge <br/>will form a cycle. find() will help us find the root of a node. If both two nodes of the new edge do not have<br/>the same root, then we add it into MST. Click next to see how this work.</h3>",
        "starterCode": "Map = [\r\n    ('A','B',1),('A','C',2),\r\n    ('B','C',6),('B','D',11),\r\n    ('C','D',9),('C','E',13),\r\n    ('D','E',7),('D','F',3),\r\n    ('E','F',4)\r\n    ]\r\nnodes = ('ABCDEF')\r\nMap.sort(key=lambda x:x[2])\r\ntrees = dict()\r\nfor i in nodes:\r\n    trees[i]=i\r\ndef find_node(x):\r\n    if trees[x]!=x:\r\n       trees[x]=find_node(trees[x])\r\n    return trees[x]\r\nmst=[]\r\nn=len(nodes)-1\r\nfor edge in Map:\r\n    v1,v2,_=edge\r\n    if find_node(v1)!=find_node(v2):\r\n        trees[find_node(v2)]=find_node(v1)\r\n        mst.append(edge)\r\n        print('edge '+str(len(nodes)-n)+' added')\r\n        n-=1\r\n        print(trees)\r\n        print(mst)\r\n        if n==0:\r\n            break",
        "code": "Map = [\r\n    ('A','B',1),('A','C',2),\r\n    ('B','C',6),('B','D',11),\r\n    ('C','D',9),('C','E',13),\r\n    ('D','E',7),('D','F',3),\r\n    ('E','F',4)\r\n    ]\r\nnodes = ('ABCDEF')\r\nMap.sort(key=lambda x:x[2])\r\ntrees = dict()\r\nfor i in nodes:\r\n    trees[i]=i\r\ndef find_node(x):\r\n    if trees[x]!=x:\r\n       trees[x]=find_node(trees[x])\r\n    return trees[x]\r\nmst=[]\r\nn=len(nodes)-1\r\nfor edge in Map:\r\n    v1,v2,_=edge\r\n    if find_node(v1)!=find_node(v2):\r\n        trees[find_node(v2)]=find_node(v1)\r\n        mst.append(edge)\r\n        print('edge '+str(len(nodes)-n)+' added')\r\n        n-=1\r\n        print(trees)\r\n        print(mst)\r\n        if n==0:\r\n            break",
        "answer": "Hello World!",
        "plotname": "",
        "haveplot": false,
        "nextLocked": false
    },
    {
        "instructions": "<h1>Step 7:</h1><br/> <h3>Congratulation! Now you have a minimum spanning tree of our map.<br/> Run the code and see what will return in console. It shows exactly the shortest path to go over every house.<br/> To finish the task, in this step, we need to programme our agent.<br/> The following start code is for you to control the agent.<br/>The picture here exactly shows how algorithm adds edges into MST.</h3><br/><img src='../static/img/lesson3/step1.png' class='relative'/><br/><img src='../static/img/lesson3/step2.png' class='relative'/><br/><h3>In this test, A sample answer will be provided. </h3><br/><h5>Reference: https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/</h5>",
        "starterCode": "Map = [\r\n    ('A','B',1),('A','C',2),\r\n    ('B','C',6),('B','D',11),\r\n    ('C','D',9),('C','E',13),\r\n    ('D','E',7),('D','F',3),\r\n    ('E','F',4)\r\n    ]\r\nnodes = ('ABCDEF')\r\nMap.sort(key=lambda x:x[2])\r\ntrees = dict()\r\nfor i in nodes:\r\n    trees[i]=i\r\ndef find_node(x):\r\n    if trees[x]!=x:\r\n       trees[x]=find_node(trees[x])\r\n    return trees[x]\r\nmst=[]\r\nn=len(nodes)-1\r\nfor edge in Map:\r\n    v1,v2,_=edge\r\n    if find_node(v1)!=find_node(v2):\r\n        trees[find_node(v2)]=find_node(v1)\r\n        mst.append(edge)\r\n        print('edge '+str(len(nodes)-n)+' added')\r\n        n-=1\r\n        print(trees)\r\n        print(mst)\r\n        if n==0:\r\n            break\r\nagent.tpto(50,5,-20)\r\n# Remember to adjust your direction.\r\nagent.wait()\r\nfor i in range(2):\r\n      agent.moveForward()\r\nagent.place(1,'back')\r\nagent.moveForward()\r\nagent.moveForward()\r\nagent.place(1,'back')\r\nagent.tpto(51,5,-19)\r\nagent.wait()\r\nagent.turnRight()\r\nfor i in range(3):\r\n      agent.moveForward()\r\nagent.wait()\r\nagent.place(1,'back')\r\nagent.wait()\r\nagent.turnLeft()\r\nagent.wait()\r\nfor a in range(8):\r\n    agent.moveForward()\r\n    agent.moveRight()\r\nfor i in range(2):\r\n      agent.moveForward()\r\nagent.turnRight()\r\nagent.wait()\r\nagent.moveForward()\r\nagent.place(1,'back')\r\nfor a in range(4):\r\n    agent.moveForward()\r\n    agent.moveRight()\r\nagent.wait()\r\nagent.turnRight()\r\nagent.moveForward()\r\nagent.wait()\r\nagent.moveForward()\r\nagent.wait()\r\nagent.place(1,'back')\r\nfor a in range(4):\r\n    agent.moveForward()\r\nagent.place(1,'back')",
        "code": "Map = [\r\n    ('A','B',1),('A','C',2),\r\n    ('B','C',6),('B','D',11),\r\n    ('C','D',9),('C','E',13),\r\n    ('D','E',7),('D','F',3),\r\n    ('E','F',4)\r\n    ]\r\nnodes = ('ABCDEF')\r\nMap.sort(key=lambda x:x[2])\r\ntrees = dict()\r\nfor i in nodes:\r\n    trees[i]=i\r\ndef find_node(x):\r\n    if trees[x]!=x:\r\n       trees[x]=find_node(trees[x])\r\n    return trees[x]\r\nmst=[]\r\nn=len(nodes)-1\r\nfor edge in Map:\r\n    v1,v2,_=edge\r\n    if find_node(v1)!=find_node(v2):\r\n        trees[find_node(v2)]=find_node(v1)\r\n        mst.append(edge)\r\n        print('edge '+str(len(nodes)-n)+' added')\r\n        n-=1\r\n        print(trees)\r\n        print(mst)\r\n        if n==0:\r\n            break\r\nagent.tpto(50,5,-20)\r\n# Remember to adjust your direction.\r\nagent.wait()\r\nfor i in range(2):\r\n      agent.moveForward()\r\nagent.place(1,'back')\r\nagent.moveForward()\r\nagent.moveForward()\r\nagent.place(1,'back')\r\nagent.tpto(51,5,-19)\r\nagent.wait()\r\nagent.turnRight()\r\nfor i in range(3):\r\n      agent.moveForward()\r\nagent.wait()\r\nagent.place(1,'back')\r\nagent.wait()\r\nagent.turnLeft()\r\nagent.wait()\r\nfor a in range(8):\r\n    agent.moveForward()\r\n    agent.moveRight()\r\nfor i in range(2):\r\n      agent.moveForward()\r\nagent.turnRight()\r\nagent.wait()\r\nagent.moveForward()\r\nagent.place(1,'back')\r\nfor a in range(4):\r\n    agent.moveForward()\r\n    agent.moveRight()\r\nagent.wait()\r\nagent.turnRight()\r\nagent.moveForward()\r\nagent.wait()\r\nagent.moveForward()\r\nagent.wait()\r\nagent.place(1,'back')\r\nfor a in range(4):\r\n    agent.moveForward()\r\nagent.place(1,'back')",
        "answer": "Hello World!",
        "plotname": "",
        "haveplot": false,
        "nextLocked": false
    },
    {
        "instructions": "<h1>Bonus step:</h1><br/> <h3>Well done! If you want to test more on the algorithm, here is extra map for you. <br/><img src='../static/img/lesson3/samplemap2.png' class='relative'/></h3>",
        "starterCode": "#TODO:\r\nCreate a new map here\r\nMap = [\r\n    ]\r\n#TODO: add nodes\r\nnodes = ('')\r\nMap.sort(key=lambda x:x[2])\r\ntrees = dict()\r\nfor i in nodes:\r\n    trees[i]=i\r\ndef find_node(x):\r\n    if trees[x]!=x:\r\n       trees[x]=find_node(trees[x])\r\n    return trees[x]\r\nmst=[]\r\nn=len(nodes)-1\r\nfor edge in Map:\r\n    v1,v2,_=edge\r\n    if find_node(v1)!=find_node(v2):\r\n        trees[find_node(v2)]=find_node(v1)\r\n        mst.append(edge)\r\n        print('edge '+str(len(nodes)-n)+' added')\r\n        n-=1\r\n        print(trees)\r\n        print(mst)\r\n        if n==0:\r\n            break",
        "code": "#TODO:\r\nCreate a new map here\r\nMap = [\r\n    ]\r\n#TODO: add nodes\r\nnodes = ('')\r\nMap.sort(key=lambda x:x[2])\r\ntrees = dict()\r\nfor i in nodes:\r\n    trees[i]=i\r\ndef find_node(x):\r\n    if trees[x]!=x:\r\n       trees[x]=find_node(trees[x])\r\n    return trees[x]\r\nmst=[]\r\nn=len(nodes)-1\r\nfor edge in Map:\r\n    v1,v2,_=edge\r\n    if find_node(v1)!=find_node(v2):\r\n        trees[find_node(v2)]=find_node(v1)\r\n        mst.append(edge)\r\n        print('edge '+str(len(nodes)-n)+' added')\r\n        n-=1\r\n        print(trees)\r\n        print(mst)\r\n        if n==0:\r\n            break",
        "answer": "Hello World!",
        "plotname": "",
        "haveplot": false,
        "nextLocked": false
    }
]